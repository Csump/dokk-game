@page "/results"
@rendermode InteractiveServer
@using Game.Models
@using Game.Services

@inject GameService GameService
@inject GameState GameState
@inject NavigationManager Navigation
@inject ILogger<Results> Logger

<PageTitle>Félidő</PageTitle>

<div class="main-container">
    @if (isLoading)
    {
        <div class="text-center py-5">
            <div class="spinner-border"></div>
            <p>Dobpergés...</p>
        </div>
    }
    else if (GameState.CurrentPlayer is not null)
    {
        <section class="summary">
            <h1>Gratulálunk!</h1>
            <p>A játék felénél jársz. Vettük a fáradságot, és eddigi fáradozásaidat kiértékeltük, hogy lásd, hogyan teljesítettél eddig.</p>
        </section>

        <section class="stat-evaluation">
            @foreach (KeyValuePair<string, (string Canonical, int Value, StatType Type)> stat in GameState.CurrentPlayer!.Stats.AsDictionary())
            {
                @if (stat.Value.Type != StatType.Energy && stat.Value.Type != StatType.Success)
                {
                    var iconPath = $"src/Icons/{stat.Value.Canonical.ToLower()}.png";
                    var cssClass = $"player-stat stat-{stat.Value.Canonical.ToLower()}";

                    <div class="evaluation-card">
                        <div class="@cssClass">
                            <div class="shine" />
                            <img src="@iconPath" class="stat-icon" />
                            <span class="value">@stat.Value.Value</span>
                        </div>
                        <h3>@stat.Key</h3>
                        <p>@GetStatEvaluationText(stat)</p>
                    </div>
                }
            }
        </section>

        <div class="continue-wrapper">
            <button class="fancy-light" type="button" @onclick="ContinueAsync" disabled="@isProcessing">
                <div class="shine" />
                @(isProcessing ? "Máris..." : "Tovább →")
            </button>
        </div>
    }
</div>

@code {
    private Player? player;
    private bool isLoading = true;
    private bool isProcessing;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await EnsurePlayerAsync();
            isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task EnsurePlayerAsync()
    {
        if (!await GameState.RestorePlayerAsync())
        {
            Navigation.NavigateTo("/setup", true);
            return;
        }

        player = GameState.CurrentPlayer;
    }

    private async Task ContinueAsync()
    {
        if (player is null || isProcessing)
        {
            return;
        }

        isProcessing = true;

        try
        {
            var currentSituation = await GameService.GetCurrentSituationAsync(player);

            if (currentSituation?.NextSituationId is not null)
            {
                var (success, updatedPlayer, errorMessage) = await GameService.ContinueFromHalftimeAsync(player, currentSituation.NextSituationId.Value);
                
                if (success)
                {
                    player = updatedPlayer;
                    await GameState.UpdatePlayerAsync(player);
                    Navigation.NavigateTo("/play");
                }
                else
                {
                    Logger.LogError("Failed to continue from halftime: {Error}", errorMessage);
                }
            }
        }
        finally
        {
            isProcessing = false;
        }
    }

    private string GetStatEvaluationText(KeyValuePair<string, (string Canonical, int Value, StatType Type)> stat)
    {
        switch (stat.Value.Value)
        {
            case < 4:
                return Evaluation.GetEvaluation(stat.Value.Type, EvaluationLevel.Bad);
            case >= 6:
                return Evaluation.GetEvaluation(stat.Value.Type, EvaluationLevel.Good);
            default:
                return Evaluation.GetEvaluation(stat.Value.Type, EvaluationLevel.Average);
        }
        ;
    }
}