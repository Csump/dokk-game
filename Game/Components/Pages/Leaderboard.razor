@page "/leaderboard"
@rendermode InteractiveServer
@using Game.Models
@using Game.Services

@inject GameService GameService
@inject GameState GameState
@inject NavigationManager Navigation

<PageTitle>Rangsor</PageTitle>

<div class="main-container">
    @if (isLoading)
    {
        <div class="text-center py-5">
            <div class="spinner-border"></div>
            <p>Dobpergés...</p>
        </div>
    }
    else if (GameState.CurrentPlayer is not null)
    {
        <section class="summary">
            <h1>Pazar teljesítmény!</h1>
            <p>Magas pontszámot, kiváló teljesítményt értél el a játékban, ami azt jelenti, hogy úgy értél el magas hallgatói elégedettséget, hogy viszonylag sok energiapontod meg is maradt. A játék folyamán tehát sok  olyan jó  döntést hoztál, ami kevesebb energiabefektetéssel magasabb hallgatói elégedettséget eredményezett.</p>
        </section>

        <section class="ranking">
            @foreach (var (entry, index) in GetFilteredLeaderboard())
            {
                var isCurrent = GameState.CurrentPlayer?.Id == entry.Id;
                <div class="rank-chip @(isCurrent ? "current-player" : "") @(index == 1 ? "first" : "")">
                    <div class="rank">@index</div>
                    <div class="username">@entry.Username</div>
                    <div class="score">
                        <div class="rank-shine" />
                        @entry.TotalScore
                    </div>
                </div>
            }
        </section>

        <section class="stat-evaluation">
            @foreach (var stat in GameState.CurrentPlayer!.Stats.AsDictionary())
            {
                var iconPath = $"src/Icons/{stat.Value.Canonical.ToLower()}.png";
                var cssClass = $"player-stat stat-{stat.Value.Canonical.ToLower()}";

                <div class="evaluation-card">
                    <div class="@cssClass">
                        <div class="shine" />
                        <img src="@iconPath" class="stat-icon" />
                        <span class="value">@stat.Value.Value</span>
                    </div>
                    <h3>@stat.Key</h3>
                    <p>A kreativitás területén kevés pontot gyűjtöttél, ami arra utalhat, hogy hajlamos vagy a dolgokat inkább egy, már ismert módon megközelíteni. Ennek hátrányát leggyakrabban akkor érezheted, amikor valami kizökkent a megszokottból, az oktatási gyakorlatodban korlátozva érzed magad, esetleg túlzott energiát követel tőled vagy egyenesen lehetetlennek tűnik számodra valami. Érdemes megfigyelni, hogy mások milyen megoldásokat alkalmaznak hasonló helyzetekre; esetleg megosztani az ötleteidet olyanokkal, akik új perspektívából inspirálhatnak; illetve azonosítani önmagadban azokat a színtereket, akár hétköznapi példákat, ahol kreatívnak érzed magad.</p>
                </div>
            }
        </section>
    }
</div>

@code {
    private readonly List<Player> entries = new();
    private bool isLoading = true;


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await EnsurePlayerAsync();
            entries.Clear();
            entries.AddRange(await GameService.GetLeaderboardAsync());
            isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task EnsurePlayerAsync()
    {
        if (!await GameState.RestorePlayerAsync())
        {
            Navigation.NavigateTo("/setup", true);
            return;
        }
    }

    private IEnumerable<(Player entry, int index)> GetFilteredLeaderboard()
    {
        if (GameState.CurrentPlayer == null || entries.Count == 0)
            return Enumerable.Empty<(Player, int)>();

        var currentPlayerIndex = entries.FindIndex(p => p.Id == GameState.CurrentPlayer.Id);
        if (currentPlayerIndex == -1)
            return entries.Select((p, i) => (p, i + 1));

        var indicesToShow = new HashSet<int>();

        indicesToShow.Add(0);

        indicesToShow.Add(currentPlayerIndex);

        for (int i = Math.Max(0, currentPlayerIndex - 2); i < currentPlayerIndex; i++)
        {
            indicesToShow.Add(i);
        }

        for (int i = currentPlayerIndex + 1; i <= Math.Min(entries.Count - 1, currentPlayerIndex + 2); i++)
        {
            indicesToShow.Add(i);
        }

        return indicesToShow
            .OrderBy(i => i)
            .Select(i => (entries[i], i + 1));
    }
}

